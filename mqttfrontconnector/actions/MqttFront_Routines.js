// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE

import {mqtt} from "./mqtt_packedlib.js"


export async function createMxObj(entity) {
	return new Promise(function(resolve,reject) {
		mx.data.create({
			entity: entity,
			callback: function(obj) {
				resolve(obj);
			},
			error: function(e) {
				reject("Could not create object:", e);
			}
		}
		);
	});
}

export async function GetMxObj(UID) {
	return new Promise(function(resolve,reject) {
		mx.data.get({
			guid: UID,
			callback: function(obj) {
				//console.log("Received MxObject with GUID " + obj.getGuid());
				resolve(obj);
			}
		});
	});
}


export async function CallRemove(MxObjectUid) {
	return new Promise(function(resolve,reject) {
		console.log("Start CallRemove of : ", MxObjectUid);
		if ((MxObjectUid!=null)&(MxObjectUid!='')&(MxObjectUid!=undefined)) {
			mx.data.remove({
				guid: MxObjectUid,
				callback: function() {
					console.log("Object removed");
					resolve(true);
				},
				error: function(e) {
					console.error( e);
					reject("Could not remove object:",MxObjectUid);
				}
			});
		} else {
			resolve(true);
		}
	});
}


export async function MqttFront_ClientConnect(mqttServerURL,MqttClientUid,clientTimeout,userName,password,options) {
	return new Promise(function(resolve,reject) {

			// Prepare options for connection. 
			//var options = {clean: false,keepalive: 1};
			var connectTimeStart=performance.now();
			if (MqttClientUid!=undefined)  {
				options = Object.assign(options,{clientId:MqttClientUid});
			} 
			if (clientTimeout!=undefined)  {
				options = Object.assign(options,{connectTimeout: clientTimeout});
			}
			if ((userName!=undefined) & (password!=undefined)) {
				options = Object.assign(options,{username: userName});
				options = Object.assign(options,{password: password});
			}

			// Open MQTT client by leveraging the lib async-mqtt.js
			console.log("MqttFront : Start MQTT client        : " + MqttClientUid);
			console.log("MqttFront : Start MQTT mqttServerURL : " + mqttServerURL);
			console.log('MqttFront : Connect option           : ' + JSON.stringify(options) );
			var client
			try {
				//client = await amqtt.connectAsync(mqttServerURL,options);
				client =  mqtt.connect(mqttServerURL,options);
			} catch (e){
				//console.log(e.stack);
				//throw new Error('MqttFront : Client connection failed for server : ' + mqttServerURL);
				reject('MqttFront : Client connection failed for server : ' + mqttServerURL);
			}
			var firstConnection=true
			client.on('connect', function (connack) {
				if  (firstConnection) {
					firstConnection=false;
					var connectTimeEnd=performance.now();
					var connectTime=connectTimeEnd - connectTimeStart;					
					console.log('MqttFront : Reconnection ' + connack.sessionPresent  );
					console.log('MqttFront : Client connection successfull in ' + connectTime + ' ms.' );
					resolve(client);	
				}
					
			})
			
					

	});
}


export async function CallCommit(MxObjectInstance) {
	return new Promise(function(resolve,reject) {
		 mx.data.commit({ 
			mxobj: MxObjectInstance,
			callback: function() {
				console.log("Object committed");
				resolve(true);
			},
			error: function(e) {
				//console.error("Could not commit object:", e);
				reject("Could not commit object", e);
			}
		});
	});
}


// END EXTRA CODE

/**
 * @returns {Promise.<void>}
 */
export async function MqttFront_Routines() {
	// BEGIN USER CODE
	throw new Error("JavaScript action was not implemented");
	// END USER CODE
}
